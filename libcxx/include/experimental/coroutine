// -*- C++ -*-
//===----------------------------- coroutine -----------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

#ifndef _LIBCPP_EXPERIMENTAL_COROUTINE
#define _LIBCPP_EXPERIMENTAL_COROUTINE

/**
    experimental/coroutine synopsis

// C++next

namespace std {
namespace experimental {
inline namespace coroutines_v1 {

  // 18.11.1 coroutine traits
template <typename R, typename... ArgTypes>
class coroutine_traits;
// 18.11.2 coroutine handle
template <typename Promise = void>
class coroutine_handle;
// 18.11.2.7 comparison operators:
bool operator==(coroutine_handle<> x, coroutine_handle<> y) _NOEXCEPT;
bool operator!=(coroutine_handle<> x, coroutine_handle<> y) _NOEXCEPT;
bool operator<(coroutine_handle<> x, coroutine_handle<> y) _NOEXCEPT;
bool operator<=(coroutine_handle<> x, coroutine_handle<> y) _NOEXCEPT;
bool operator>=(coroutine_handle<> x, coroutine_handle<> y) _NOEXCEPT;
bool operator>(coroutine_handle<> x, coroutine_handle<> y) _NOEXCEPT;
// 18.11.3 trivial awaitables
struct suspend_never;
struct suspend_always;
// 18.11.2.8 hash support:
template <class T> struct hash;
template <class P> struct hash<coroutine_handle<P>>;

} // namespace coroutines_v1
} // namespace experimental
} // namespace std

 */

#include <experimental/__config>
#include <new>
#include <type_traits>
#include <functional>
#include <memory> // for hash<T*>
#include <cstddef>
#include <cassert>
#include <__debug>

#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
#pragma GCC system_header
#endif

#ifdef _LIBCPP_HAS_NO_COROUTINES
# if defined(_LIBCPP_WARNING)
    _LIBCPP_WARNING("<experimental/coroutine> cannot be used with this compiler")
# else
#   warning <experimental/coroutine> cannot be used with this compiler
# endif
#endif

#ifndef _LIBCPP_HAS_NO_COROUTINES

_LIBCPP_BEGIN_NAMESPACE_EXPERIMENTAL_COROUTINES

template <class _Tp, class = void>
struct __coroutine_traits_sfinae {};

template <class _Tp>
struct __coroutine_traits_sfinae<
    _Tp, typename __void_t<typename _Tp::promise_type>::type>
{
  using promise_type = typename _Tp::promise_type;
};

template <typename _Ret, typename... _Args>
struct coroutine_traits
    : public __coroutine_traits_sfinae<_Ret>
{
};

using __continuation_function = void(void*);

template<typename _Promise>
using __coroutine_promise_getter = _Promise&(void*);

// TODO: Ideally the compiler would be procedurally generating anonymous
// continuation-handle and suspend-point-handle types for each suspend-point.
// In the interests of getting something working quickly we implement the handle
// types in C++ code and have the compiler instantiate them with an anonymous
// per-suspend-point struct to ensure that the handle types are unique for each
// suspend-point.

template <typename _Tag>
class [[nodiscard]] __resume_continuation_handle {
public:
  constexpr __resume_continuation_handle() noexcept : __data_(nullptr) {}

  static constexpr __resume_continuation_handle __from_address(void* __data) noexcept {
    __resume_continuation_handle __handle;
    __handle.__data_ = __data;
    return __handle;
  }

  constexpr explicit operator bool() const noexcept { return __data_ != nullptr; }
  constexpr bool operator!() const noexcept { return __data_ == nullptr; }

  void operator()() const {
    __execute(__data_);
  }

  static constexpr __continuation_function* __continuation() noexcept {
    return &__resume_continuation_handle::__execute;
  }

  void* __address() const noexcept { return __data_; }

private:

  static void __execute(void* __data) {
    _LIBCPP_ASSERT(__data, "UB to invoke an invalid continuation");
    __builtin_coro_resume(__data);
  }

  void* __data_;
};

template <typename _Tag>
class [[nodiscard]] __set_done_continuation_handle {
public:
  constexpr __set_done_continuation_handle() noexcept : __data_(nullptr) {}

  static constexpr __set_done_continuation_handle __from_address(void* __data) noexcept {
    __set_done_continuation_handle __handle;
    __handle.__data_ = __data;
    return __handle;
  }

  constexpr explicit operator bool() const noexcept { return __data_ != nullptr; }
  constexpr bool operator!() const noexcept { return __data_ == nullptr; }

  void operator()() const {
    __execute(__data_);
  }

  static constexpr __continuation_function* __continuation() noexcept {
    return &__set_done_continuation_handle::__execute;
  }

  void* __address() const noexcept { return __data_; }

private:

  static void __execute(void* __data) {
    _LIBCPP_ASSERT(__data, "UB to invoke an invalid continuation");
    // HACK: Not actually "destroy" here for suspend-points other than the
    // initial/final suspend-points.
    __builtin_coro_destroy(__data);
  }

  void* __data_;
};

template <typename _Tag>
class [[nodiscard]] __noop_continuation_handle {
public:
  constexpr __noop_continuation_handle() noexcept {}
  constexpr explicit operator bool() const noexcept { return __data_ != nullptr; }
  constexpr bool operator!() const noexcept { return __data_ == nullptr; }
  void operator()() const noexcept {}
  static constexpr __continuation_function* __continuation() noexcept {
    return &__noop_continuation_handle::__execute;
  }
  void* __address() const noexcept { return __data_; }
  static constexpr __noop_continuation_handle __from_address(void* __data) noexcept {
    __noop_continuation_handle __handle;
    __handle.__data_ = __data;
    return __handle;
  }
private:
  static void __execute(void*) noexcept {
    // Do nothing.
  }

  void* __data_;
};

// Suspend-point handle passed to promise.get_return_object() call.
template <typename _Tag, typename _Promise>
class [[nodiscard]] __initial_suspend_point_handle {
public:
  using resume_handle = __resume_continuation_handle<_Tag>;
  using set_done_handle = __noop_continuation_handle<_Tag>;

  constexpr __initial_suspend_point_handle() noexcept : __data_(nullptr) {}

  static constexpr __initial_suspend_point_handle __from_address(void* __data) noexcept {
    __initial_suspend_point_handle __handle;
    __handle.__data_ = __data;
    return __handle;
  }

  constexpr explicit operator bool() const noexcept { return __data_ != nullptr; }
  constexpr bool operator!() const noexcept { return __data_ == nullptr; }

  _Promise& promise() const {
    return __promise(__data_);
  }

  resume_handle resume() const noexcept {
    return resume_handle::__from_address(__data_);
  }

  set_done_handle set_done() const noexcept {
    return set_done_handle::__from_address(__data_);
  }

  void destroy() const {
    __destroy(__data_);
  }

  void* __address() const noexcept { return __data_; }

  static constexpr __coroutine_promise_getter<_Promise>* __promise_getter() noexcept {
    return &__initial_suspend_point_handle::__promise;
  }

  static constexpr __continuation_function* __set_done_continuation() noexcept {
    return set_done_handle::__continuation();
  }

  static constexpr __continuation_function* __resume_continuation() noexcept {
    return resume_handle::__continuation();
  }

  static constexpr __continuation_function* __destroy_continuation() noexcept {
    return &__initial_suspend_point_handle::__destroy;
  }

private:

  static _Promise& __promise(void* __data) {
    _LIBCPP_ASSERT(__data, "UB to query promise of an invalid handle");
    return *static_cast<_Promise*>(
        __builtin_coro_promise(__data, _LIBCPP_ALIGNOF(_Promise), false));
  }

  static void __destroy(void* __data) {
    _LIBCPP_ASSERT(__data, "UB to destroy() an invalid coroutine");
    __builtin_coro_destroy(__data);
  }

  void* __data_;
};

// Suspend-point handle type passed to 'co_await' and 'co_yield' expressions.
template <typename _Tag, typename _Promise>
class [[nodiscard]] __normal_suspend_point_handle {
public:
  using resume_handle = __resume_continuation_handle<_Tag>;
  using set_done_handle = __set_done_continuation_handle<_Tag>;

  constexpr __normal_suspend_point_handle() noexcept : __data_(nullptr) {}

  static constexpr __normal_suspend_point_handle __from_address(void* __data) noexcept {
    __normal_suspend_point_handle __handle;
    __handle.__data_ = __data;
    return __handle;
  }

  constexpr explicit operator bool() const noexcept { return __data_ != nullptr; }
  constexpr bool operator!() const noexcept { return __data_ == nullptr; }

  _Promise& promise() const {
    return __promise(__data_);
  }

  resume_handle resume() const noexcept {
    return resume_handle::__from_address(__data_);
  }

  set_done_handle set_done() const noexcept {
    return set_done_handle::__from_address(__data_);
  }

  void* __address() const noexcept { return __data_; }

  static constexpr __coroutine_promise_getter<_Promise>* __promise_getter() noexcept {
    return &__normal_suspend_point_handle::__promise;
  }

  static constexpr __continuation_function* __resume_continuation() noexcept {
    return resume_handle::__continuation();
  }

  static constexpr __continuation_function* __set_done_continuation() noexcept {
    return set_done_handle::__continuation();
  }

private:

  static _Promise& __promise(void* __data) {
    _LIBCPP_ASSERT(__data, "UB to query promise of an invalid handle");
    return *static_cast<_Promise*>(
        __builtin_coro_promise(__data, _LIBCPP_ALIGNOF(_Promise), false));
  }

  void* __data_;
};

class _LIBCPP_TYPE_VIS [[nodiscard]] continuation_handle {
public:
  _LIBCPP_INLINE_VISIBILITY
  _LIBCPP_CONSTEXPR continuation_handle() _NOEXCEPT : __data_(nullptr), __execute_(nullptr) {}

  // Implicit conversion from concrete handle types.
  template<typename _Tag>
  _LIBCPP_CONSTEXPR continuation_handle(__resume_continuation_handle<_Tag> __handle)
  : __data_(__handle.__address())
  , __execute_(__handle.__continuation())
  {}

  template<typename _Tag>
  _LIBCPP_CONSTEXPR continuation_handle(__set_done_continuation_handle<_Tag> __handle)
  : __data_(__handle.__address())
  , __execute_(__handle.__continuation())
  {}

  _LIBCPP_INLINE_VISIBILITY
  _LIBCPP_CONSTEXPR explicit operator bool() const _NOEXCEPT { return __execute_; }

  _LIBCPP_INLINE_VISIBILITY
  _LIBCPP_CONSTEXPR bool operator!() const _NOEXCEPT { return !__execute_; }

  _LIBCPP_INLINE_VISIBILITY
  void operator()() const {
    _LIBCPP_ASSERT(__execute_, "UB to invoke an invalid continuation");
    __execute_(__data_);
  }

  constexpr void* __address() const _NOEXCEPT { return __data_; }

  constexpr __continuation_function* __continuation() const noexcept {
    return __execute_;
  }

  static continuation_handle __from_address(void* __data, __continuation_function* __execute) noexcept {
    continuation_handle __handle;
    __handle.__data_ = __data;
    __handle.__execute_ = __execute;
    return __handle;
  }

private:
  void* __data_;
  __continuation_function* __execute_;
};

//////////////////////
// noop_continuation()

struct __noop_continuation_tag {};

using noop_continuation_handle = __noop_continuation_handle<__noop_continuation_tag>;

noop_continuation_handle noop_continuation() _NOEXCEPT {
  return noop_continuation_handle::__from_address(__builtin_coro_noop());
}

////////////////
// Implementation details of the suspend_point_handle type.

template<typename... _Entries>
struct __suspend_point_vtable;

template<>
struct __suspend_point_vtable<> {};

template<typename _First, typename... _Rest>
struct __suspend_point_vtable<_First, _Rest...> : private __suspend_point_vtable<_Rest...> {
public:
  constexpr __suspend_point_vtable(_First __first, _Rest... __rest) noexcept
  : __suspend_point_vtable<_Rest...>(__rest...)
  , __data_(__first)
  {}

  template <typename _Tp>
  constexpr const auto& __get() const noexcept {
    if constexpr (std::is_same_v<_Tp, _First>) {
      return __data_;
    } else {
      return __suspend_point_vtable<_Rest...>::template __get<_Tp>();
    }
  }
private:
  _First __data_;
};

template<typename... _Entries>
__suspend_point_vtable(_Entries...) -> __suspend_point_vtable<_Entries...>;

struct with_set_done {
  struct __vtable_entry {
    __continuation_function* __func;
  };

  template <
    typename _ConcreteHandle,
    std::enable_if_t<std::is_same_v<
      decltype(_ConcreteHandle::__set_done_continuation()),
      __continuation_function*>, int> = 0>
  static constexpr __vtable_entry __make_vtable_entry() {
    return __vtable_entry{_ConcreteHandle::__set_done_continuation()};
  }

  template <typename _Base>
  class _LIBCPP_TEMPLATE_VIS __mixin : public _Base {
  public:
    using set_done_handle = continuation_handle;

    _LIBCPP_INLINE_VISIBILITY
    set_done_handle set_done() const {
      _LIBCPP_ASSERT(this->__vtable_, "set_done() can only be called on a valid handle");
      return set_done_handle::__from_address(
        this->__handle_,
        this->__vtable_->template __get<__vtable_entry>().__func);
    }
  protected:
    using _Base::_Base;
  };
};

struct with_destroy {
  struct __vtable_entry {
  };

  template <
    typename _ConcreteHandle,
    std::enable_if_t<std::is_same_v<
      decltype(_ConcreteHandle::__destroy_continuation()),
      __continuation_function*>, int> = 0>
  static constexpr __vtable_entry __make_vtable_entry() {
    return __vtable_entry{};
  }

  template <typename _Base>
  class _LIBCPP_TEMPLATE_VIS __mixin : public _Base {
  public:
    _LIBCPP_INLINE_VISIBILITY
    void destroy() const {
      // TODO: Make this indirect through a vtable entry.
      // For now we avoid this so that the compiler can more easily see the
      // call to __builtin_coro_destroy() and so have a better chance at
      // eliding the coroutine frame allocation.
      // We might need to introduce some other kind of intrinsic that annotates
      // the end-of-lifetime without actually performing the destroy.
      _LIBCPP_ASSERT(this->__handle_, "destroy() can only be called on a valid handle");
      __builtin_coro_destroy(this->__handle_);
    }
  protected:
    using _Base::_Base;
  };
};

struct with_resume {
  struct __vtable_entry {
    __continuation_function* __func;
  };

  template <
    typename _ConcreteHandle,
    std::enable_if_t<std::is_same_v<
      decltype(_ConcreteHandle::__resume_continuation()),
      __continuation_function*>, int> = 0>
  static constexpr __vtable_entry __make_vtable_entry() {
    return __vtable_entry{_ConcreteHandle::__resume_continuation()};
  }

  template <typename _Base>
  class _LIBCPP_TEMPLATE_VIS __mixin : public _Base {
  public:
    using resume_handle = continuation_handle;

    _LIBCPP_INLINE_VISIBILITY
    resume_handle resume() const {
      _LIBCPP_ASSERT(this->__vtable_, "resume() can only be called on a valid handle");
      return resume_handle::__from_address(
        this->__handle_,
        this->__vtable_->template __get<__vtable_entry>().__func);
    }
  protected:
    using _Base::_Base;
  };
};

template <typename _Promise>
struct with_promise {
  struct __vtable_entry {
    __coroutine_promise_getter<_Promise>* __func;
  };

  template <
    typename _ConcreteHandle,
    std::enable_if_t<std::is_same_v<
      decltype(_ConcreteHandle::__promise_getter()),
      __coroutine_promise_getter<_Promise>*>, int> = 0>
  static constexpr __vtable_entry __make_vtable_entry() {
    return __vtable_entry{_ConcreteHandle::__promise_getter()};
  }

  template <typename _Base>
  class _LIBCPP_TEMPLATE_VIS __mixin : public _Base {
  public:
    _LIBCPP_INLINE_VISIBILITY
    _Promise& promise() const {
      _LIBCPP_ASSERT(this->__vtable_, "promise() can only be called on a valid handle");
      return this->__vtable_->template __get<__vtable_entry>().__func(this->__handle_);
    }
  protected:
    using _Base::_Base;
  };
};

template <typename _Tp>
struct __is_valid_suspend_point_operation : std::false_type {};
template <>
struct __is_valid_suspend_point_operation<with_destroy> : std::true_type {};
template <>
struct __is_valid_suspend_point_operation<with_resume> : std::true_type {};
template <>
struct __is_valid_suspend_point_operation<with_set_done> : std::true_type {};
template <typename _Promise>
struct __is_valid_suspend_point_operation<with_promise<_Promise>> : std::true_type {};

template <typename _Base, typename... _Operations>
struct __make_suspend_point_handle;

template <typename _Base, typename _FirstOp, typename... _RemainingOps>
struct __make_suspend_point_handle<_Base, _FirstOp, _RemainingOps...> : __make_suspend_point_handle<
  typename _FirstOp::template __mixin<_Base>,
  _RemainingOps...> {};

template <typename _Result>
struct __make_suspend_point_handle<_Result> {
  using type = _Result;
};

template<typename _VTable>
class _LIBCPP_TYPE_VIS __suspend_point_handle_base {
public:
  _LIBCPP_INLINE_VISIBILITY
  _LIBCPP_CONSTEXPR explicit operator bool() const _NOEXCEPT { return __handle_; }

  _LIBCPP_INLINE_VISIBILITY
  _LIBCPP_CONSTEXPR bool operator!() const _NOEXCEPT { return !__handle_; }

protected:
  _LIBCPP_CONSTEXPR __suspend_point_handle_base() _NOEXCEPT
  : __handle_(nullptr), __vtable_(nullptr) {}

  void* __handle_;
  const _VTable* __vtable_;
};

template <typename... _Operations>
using __suspend_point_vtable_t =
  __suspend_point_vtable<typename _Operations::__vtable_entry...>;

template <typename... _Operations>
using __suspend_point_handle_base_t =
  typename __make_suspend_point_handle<
    __suspend_point_handle_base<__suspend_point_vtable_t<_Operations...>>,
    _Operations...>::type;

template <typename... _Operations>
class _LIBCPP_TEMPLATE_VIS [[nodiscard]] suspend_point_handle
  : public __suspend_point_handle_base_t<_Operations...> {
  using _VTable = __suspend_point_vtable_t<_Operations...>;

  static_assert(
    conjunction_v<__is_valid_suspend_point_operation<_Operations>...>,
    "Template parameters must be one of the built-in suspend-point operations");

public:
  _LIBCPP_INLINE_VISIBILITY
  _LIBCPP_CONSTEXPR suspend_point_handle() _NOEXCEPT = default;

  _LIBCPP_INLINE_VISIBILITY
  _LIBCPP_CONSTEXPR suspend_point_handle(const suspend_point_handle&) _NOEXCEPT = default;

  _LIBCPP_INLINE_VISIBILITY
  ~suspend_point_handle() _NOEXCEPT = default;

  // Allow implicit conversion from a concrete suspend-point handle.

  template <
    typename _ConcreteHandle,
    enable_if_t<std::is_void_v<std::void_t<
      decltype(_Operations::template __make_vtable_entry<_ConcreteHandle>())...>>, int> = 0>
  suspend_point_handle(_ConcreteHandle __handle) _NOEXCEPT {
    static constexpr _VTable __vtable{_Operations::template __make_vtable_entry<_ConcreteHandle>()...};
    this->__handle_ = __handle.__address();
    this->__vtable_ = &__vtable;
  }
};

struct suspend_never {
  _LIBCPP_INLINE_VISIBILITY
  bool await_ready() const _NOEXCEPT { return true; }
  _LIBCPP_INLINE_VISIBILITY
  template<typename _Handle>
  void await_suspend(_Handle) const _NOEXCEPT {}
  _LIBCPP_INLINE_VISIBILITY
  void await_resume() const _NOEXCEPT {}
};

_LIBCPP_END_NAMESPACE_EXPERIMENTAL_COROUTINES

#endif // !defined(_LIBCPP_HAS_NO_COROUTINES)

#endif /* _LIBCPP_EXPERIMENTAL_COROUTINE */
