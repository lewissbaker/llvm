// -*- C++ -*-
//===----------------------------- coroutine -----------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

#ifndef _LIBCPP_EXPERIMENTAL_COROUTINE
#define _LIBCPP_EXPERIMENTAL_COROUTINE

/**
    experimental/coroutine synopsis

// C++next

namespace std {
namespace experimental {
inline namespace coroutines_v1 {

  // 18.11.1 coroutine traits
template <typename R, typename... ArgTypes>
class coroutine_traits;
// 18.11.2 coroutine handle
template <typename Promise = void>
class coroutine_handle;
// 18.11.2.7 comparison operators:
bool operator==(coroutine_handle<> x, coroutine_handle<> y) _NOEXCEPT;
bool operator!=(coroutine_handle<> x, coroutine_handle<> y) _NOEXCEPT;
bool operator<(coroutine_handle<> x, coroutine_handle<> y) _NOEXCEPT;
bool operator<=(coroutine_handle<> x, coroutine_handle<> y) _NOEXCEPT;
bool operator>=(coroutine_handle<> x, coroutine_handle<> y) _NOEXCEPT;
bool operator>(coroutine_handle<> x, coroutine_handle<> y) _NOEXCEPT;
// 18.11.3 trivial awaitables
struct suspend_never;
struct suspend_always;
// 18.11.2.8 hash support:
template <class T> struct hash;
template <class P> struct hash<coroutine_handle<P>>;

} // namespace coroutines_v1
} // namespace experimental
} // namespace std

 */

#include <experimental/__config>
#include <new>
#include <type_traits>
#include <functional>
#include <memory> // for hash<T*>
#include <cstddef>
#include <cassert>
#include <__debug>

#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
#pragma GCC system_header
#endif

#ifdef _LIBCPP_HAS_NO_COROUTINES
# if defined(_LIBCPP_WARNING)
    _LIBCPP_WARNING("<experimental/coroutine> cannot be used with this compiler")
# else
#   warning <experimental/coroutine> cannot be used with this compiler
# endif
#endif

#ifndef _LIBCPP_HAS_NO_COROUTINES

_LIBCPP_BEGIN_NAMESPACE_EXPERIMENTAL_COROUTINES

template <class _Tp, class = void>
struct __coroutine_traits_sfinae {};

template <class _Tp>
struct __coroutine_traits_sfinae<
    _Tp, typename __void_t<typename _Tp::promise_type>::type>
{
  using promise_type = typename _Tp::promise_type;
};

template <typename _Ret, typename... _Args>
struct coroutine_traits
    : public __coroutine_traits_sfinae<_Ret>
{
};

class with_set_done;
class with_resume;

class _LIBCPP_TYPE_VIS continuation_handle {
public:
  _LIBCPP_INLINE_VISIBILITY
  _LIBCPP_CONSTEXPR continuation_handle() _NOEXCEPT : __handle_(nullptr), __execute_(nullptr) {}

  _LIBCPP_INLINE_VISIBILITY
  _LIBCPP_CONSTEXPR explicit operator bool() const _NOEXCEPT { return __execute_; }

  _LIBCPP_INLINE_VISIBILITY
  _LIBCPP_CONSTEXPR bool operator!() const _NOEXCEPT { return !__execute_; }

  _LIBCPP_INLINE_VISIBILITY
  void operator()() const {
    _LIBCPP_ASSERT(__execute_, "UB to invoke an invalid continuation");
    __execute_(__handle_);
  }

  void* __address() const _NOEXCEPT { return __handle_; }

private:
  friend with_set_done;
  friend with_resume;

  explicit continuation_handle(void* __handle, void (*__execute)(void*)) _NOEXCEPT
  : __handle_(__handle)
  , __execute_(__execute)
  {}

  void* __handle_;
  void (*__execute_)(void*);
};

class _LIBCPP_TYPE_VIS __suspend_point_handle_base {
public:
  _LIBCPP_INLINE_VISIBILITY
  _LIBCPP_CONSTEXPR explicit operator bool() const _NOEXCEPT { return __handle_; }

  _LIBCPP_INLINE_VISIBILITY
  _LIBCPP_CONSTEXPR bool operator!() const _NOEXCEPT { return !__handle_; }
protected:
  _LIBCPP_CONSTEXPR __suspend_point_handle_base() _NOEXCEPT : __handle_(nullptr) {}
  void* __handle_;
};

struct with_set_done {
  template <typename _Base>
  class _LIBCPP_TEMPLATE_VIS __mixin : public _Base {
  public:
    _LIBCPP_INLINE_VISIBILITY
    continuation_handle set_done() const {
      return continuation_handle{this->__handle_, [](void* __handle) {
        // TODO: Implement me.
        __builtin_coro_resume(__handle);
      }};
    }
  protected:
    using _Base::_Base;
  };
};

struct with_destroy {
  template <typename _Base>
  class _LIBCPP_TEMPLATE_VIS __mixin : public _Base {
  public:
    _LIBCPP_INLINE_VISIBILITY
    void destroy() const {
      _LIBCPP_ASSERT(this->__handle_, "destroy() can only be called on a valid handle");
      __builtin_coro_destroy(this->__handle_);
    }
  protected:
    using _Base::_Base;
  };
};

struct with_resume {
  template <typename _Base>
  class _LIBCPP_TEMPLATE_VIS __mixin : public _Base {
  public:
    _LIBCPP_INLINE_VISIBILITY
    continuation_handle resume() const {
      _LIBCPP_ASSERT(this->__handle_, "resume() can only be called on a valid handle");
      return continuation_handle{this->__handle_, [](void* __handle) {
        __builtin_coro_resume(__handle);
      }};
    }
  protected:
    using _Base::_Base;
  };
};

template <typename _Promise>
struct with_promise {
  template <typename _Base>
  class _LIBCPP_TEMPLATE_VIS __mixin : public _Base {
  public:
    _LIBCPP_INLINE_VISIBILITY
    _Promise& promise() const {
      return *static_cast<_Promise*>(
        __builtin_coro_promise(this->__handle_, _LIBCPP_ALIGNOF(_Promise), false));
    }
  protected:
    using _Base::_Base;
  };
};

template <typename _Tp>
struct __is_valid_suspend_point_operation : std::false_type {};
template <>
struct __is_valid_suspend_point_operation<with_destroy> : std::true_type {};
template <>
struct __is_valid_suspend_point_operation<with_resume> : std::true_type {};
template <>
struct __is_valid_suspend_point_operation<with_set_done> : std::true_type {};
template <typename _Promise>
struct __is_valid_suspend_point_operation<with_promise<_Promise>> : std::true_type {};

template <typename _Base, typename... _Operations>
struct __make_suspend_point_handle;

template <typename _Base, typename _FirstOp, typename... _RemainingOps>
struct __make_suspend_point_handle<_Base, _FirstOp, _RemainingOps...> : __make_suspend_point_handle<
  typename _FirstOp::template __mixin<_Base>,
  _RemainingOps...> {};

template <typename _Result>
struct __make_suspend_point_handle<_Result> {
  using type = _Result;
};

template <typename... _Operations>
using __suspend_point_handle_base_t =
  typename __make_suspend_point_handle<
    __suspend_point_handle_base, _Operations...>::type;

template <typename... _Ts>
struct __is_subset_of {
  template <typename _U>
  using __is_member = disjunction<is_same<_U, _Ts>...>;

  template <typename... _Us>
  static constexpr bool __value = conjunction_v<__is_member<_Us>...>;
};

template <typename... _Operations>
class _LIBCPP_TEMPLATE_VIS suspend_point_handle
  : public __suspend_point_handle_base_t<_Operations...> {
  using _Base = __suspend_point_handle_base_t<_Operations...>;

  static_assert(
    conjunction_v<__is_valid_suspend_point_operation<_Operations>...>,
    "Template parameters must be one of the built-in suspend-point operations");

  template <typename... _OtherOperations>
  friend class suspend_point_handle;

public:
  _LIBCPP_INLINE_VISIBILITY
  _LIBCPP_CONSTEXPR suspend_point_handle() _NOEXCEPT = default;

  _LIBCPP_INLINE_VISIBILITY
  _LIBCPP_CONSTEXPR suspend_point_handle(const suspend_point_handle&) _NOEXCEPT = default;

  _LIBCPP_INLINE_VISIBILITY
  ~suspend_point_handle() _NOEXCEPT = default;

  // Allow implicit conversion from a suspend_point_handle with a wider interface.
  template <
    typename... _OtherOperations,
    enable_if_t<__is_subset_of<_OtherOperations...>::template __value<_Operations...>, int> = 0>
  suspend_point_handle(suspend_point_handle<_OtherOperations...> __sph) _NOEXCEPT
  {
    this->__handle_ = __sph.__handle_;
  }

  // Allow construction from the coroutine frame pointer.
  // This is called by the compiler.
  static suspend_point_handle __from_address(void* __handle) _NOEXCEPT {
    suspend_point_handle __h;
    __h.__handle_ = __handle;
    return __h;
  }
};

template <typename _Promise = void>
class _LIBCPP_TEMPLATE_VIS coroutine_handle;

template <>
class _LIBCPP_TEMPLATE_VIS coroutine_handle<void> {
public:
    _LIBCPP_INLINE_VISIBILITY
    _LIBCPP_CONSTEXPR coroutine_handle() _NOEXCEPT : __handle_(nullptr) {}

    _LIBCPP_INLINE_VISIBILITY
    _LIBCPP_CONSTEXPR coroutine_handle(nullptr_t) _NOEXCEPT : __handle_(nullptr) {}

    _LIBCPP_INLINE_VISIBILITY
    coroutine_handle& operator=(nullptr_t) _NOEXCEPT {
        __handle_ = nullptr;
        return *this;
    }

    _LIBCPP_INLINE_VISIBILITY
    _LIBCPP_CONSTEXPR void* address() const _NOEXCEPT { return __handle_; }

    _LIBCPP_INLINE_VISIBILITY
    _LIBCPP_CONSTEXPR explicit operator bool() const _NOEXCEPT { return __handle_; }

    _LIBCPP_INLINE_VISIBILITY
    void operator()() { resume(); }

    _LIBCPP_INLINE_VISIBILITY
    void resume() {
      _LIBCPP_ASSERT(__is_suspended(),
                     "resume() can only be called on suspended coroutines");
      _LIBCPP_ASSERT(!done(),
                "resume() has undefined behavior when the coroutine is done");
      __builtin_coro_resume(__handle_);
    }

    _LIBCPP_INLINE_VISIBILITY
    void destroy() {
      _LIBCPP_ASSERT(__is_suspended(),
                     "destroy() can only be called on suspended coroutines");
      __builtin_coro_destroy(__handle_);
    }

    _LIBCPP_INLINE_VISIBILITY
    bool done() const {
      _LIBCPP_ASSERT(__is_suspended(),
                     "done() can only be called on suspended coroutines");
      return __builtin_coro_done(__handle_);
    }

public:
    _LIBCPP_INLINE_VISIBILITY
    static coroutine_handle from_address(void* __addr) _NOEXCEPT {
        coroutine_handle __tmp;
        __tmp.__handle_ = __addr;
        return __tmp;
    }

    // FIXME: Should from_address(nullptr) be allowed?
    _LIBCPP_INLINE_VISIBILITY
    static coroutine_handle from_address(nullptr_t) _NOEXCEPT {
      return coroutine_handle(nullptr);
    }

    template <class _Tp, bool _CallIsValid = false>
    static coroutine_handle from_address(_Tp*) {
      static_assert(_CallIsValid,
       "coroutine_handle<void>::from_address cannot be called with "
        "non-void pointers");
    }

private:
  bool __is_suspended() const _NOEXCEPT  {
    // FIXME actually implement a check for if the coro is suspended.
    return __handle_;
  }

  template <class _PromiseT> friend class coroutine_handle;
  void* __handle_;
};

// 18.11.2.7 comparison operators:
inline _LIBCPP_INLINE_VISIBILITY
bool operator==(coroutine_handle<> __x, coroutine_handle<> __y) _NOEXCEPT {
    return __x.address() == __y.address();
}
inline _LIBCPP_INLINE_VISIBILITY
bool operator!=(coroutine_handle<> __x, coroutine_handle<> __y) _NOEXCEPT {
    return !(__x == __y);
}
inline _LIBCPP_INLINE_VISIBILITY
bool operator<(coroutine_handle<> __x, coroutine_handle<> __y) _NOEXCEPT {
    return less<void*>()(__x.address(), __y.address());
}
inline _LIBCPP_INLINE_VISIBILITY
bool operator>(coroutine_handle<> __x, coroutine_handle<> __y) _NOEXCEPT {
    return __y < __x;
}
inline _LIBCPP_INLINE_VISIBILITY
bool operator<=(coroutine_handle<> __x, coroutine_handle<> __y) _NOEXCEPT {
    return !(__x > __y);
}
inline _LIBCPP_INLINE_VISIBILITY
bool operator>=(coroutine_handle<> __x, coroutine_handle<> __y) _NOEXCEPT {
    return !(__x < __y);
}

template <typename _Promise>
class _LIBCPP_TEMPLATE_VIS coroutine_handle : public coroutine_handle<> {
    using _Base = coroutine_handle<>;
public:
#ifndef _LIBCPP_CXX03_LANG
    // 18.11.2.1 construct/reset
    using coroutine_handle<>::coroutine_handle;
#else
    _LIBCPP_INLINE_VISIBILITY coroutine_handle() _NOEXCEPT : _Base() {}
    _LIBCPP_INLINE_VISIBILITY coroutine_handle(nullptr_t) _NOEXCEPT : _Base(nullptr) {}
#endif
    _LIBCPP_INLINE_VISIBILITY
    coroutine_handle& operator=(nullptr_t) _NOEXCEPT {
        _Base::operator=(nullptr);
        return *this;
    }

    _LIBCPP_INLINE_VISIBILITY
    _Promise& promise() const {
        return *static_cast<_Promise*>(
            __builtin_coro_promise(this->__handle_, _LIBCPP_ALIGNOF(_Promise), false));
    }

public:
    _LIBCPP_INLINE_VISIBILITY
    static coroutine_handle from_address(void* __addr) _NOEXCEPT {
        coroutine_handle __tmp;
        __tmp.__handle_ = __addr;
        return __tmp;
    }

    // NOTE: this overload isn't required by the standard but is needed so
    // the deleted _Promise* overload doesn't make from_address(nullptr)
    // ambiguous.
    // FIXME: should from_address work with nullptr?
    _LIBCPP_INLINE_VISIBILITY
    static coroutine_handle from_address(nullptr_t) _NOEXCEPT {
      return coroutine_handle(nullptr);
    }

    template <class _Tp, bool _CallIsValid = false>
    static coroutine_handle from_address(_Tp*) {
      static_assert(_CallIsValid,
       "coroutine_handle<promise_type>::from_address cannot be called with "
        "non-void pointers");
    }

    template <bool _CallIsValid = false>
    static coroutine_handle from_address(_Promise*) {
      static_assert(_CallIsValid,
       "coroutine_handle<promise_type>::from_address cannot be used with "
        "pointers to the coroutine's promise type; use 'from_promise' instead");
    }

    _LIBCPP_INLINE_VISIBILITY
    static coroutine_handle from_promise(_Promise& __promise) _NOEXCEPT {
        typedef typename remove_cv<_Promise>::type _RawPromise;
        coroutine_handle __tmp;
        __tmp.__handle_ = __builtin_coro_promise(
            _VSTD::addressof(const_cast<_RawPromise&>(__promise)),
             _LIBCPP_ALIGNOF(_Promise), true);
        return __tmp;
    }
};

#if __has_builtin(__builtin_coro_noop)
struct noop_coroutine_promise {};

template <>
class _LIBCPP_TEMPLATE_VIS coroutine_handle<noop_coroutine_promise>
    : public coroutine_handle<> {
  using _Base = coroutine_handle<>;
  using _Promise = noop_coroutine_promise;
public:

  _LIBCPP_INLINE_VISIBILITY
  _Promise& promise() const {
    return *static_cast<_Promise*>(
      __builtin_coro_promise(this->__handle_, _LIBCPP_ALIGNOF(_Promise), false));
  }

  _LIBCPP_CONSTEXPR explicit operator bool() const _NOEXCEPT { return true; }
  _LIBCPP_CONSTEXPR bool done() const _NOEXCEPT { return false; }

  _LIBCPP_CONSTEXPR_AFTER_CXX17 void operator()() const _NOEXCEPT {}
  _LIBCPP_CONSTEXPR_AFTER_CXX17 void resume() const _NOEXCEPT {}
  _LIBCPP_CONSTEXPR_AFTER_CXX17 void destroy() const _NOEXCEPT {}

private:
  _LIBCPP_INLINE_VISIBILITY
  friend coroutine_handle<noop_coroutine_promise> noop_coroutine() _NOEXCEPT;

  _LIBCPP_INLINE_VISIBILITY coroutine_handle() _NOEXCEPT {
    this->__handle_ = __builtin_coro_noop();
  }
};

using noop_coroutine_handle = coroutine_handle<noop_coroutine_promise>;

inline _LIBCPP_INLINE_VISIBILITY
noop_coroutine_handle noop_coroutine() _NOEXCEPT {
  return noop_coroutine_handle();
}
#endif // __has_builtin(__builtin_coro_noop)

struct suspend_never {
  _LIBCPP_INLINE_VISIBILITY
  bool await_ready() const _NOEXCEPT { return true; }
  _LIBCPP_INLINE_VISIBILITY
  void await_suspend(coroutine_handle<>) const _NOEXCEPT {}
  _LIBCPP_INLINE_VISIBILITY
  void await_resume() const _NOEXCEPT {}
};

struct suspend_always {
  _LIBCPP_INLINE_VISIBILITY
  bool await_ready() const _NOEXCEPT { return false; }
  _LIBCPP_INLINE_VISIBILITY
  void await_suspend(coroutine_handle<>) const _NOEXCEPT {}
  _LIBCPP_INLINE_VISIBILITY
  void await_resume() const _NOEXCEPT {}
};

_LIBCPP_END_NAMESPACE_EXPERIMENTAL_COROUTINES

_LIBCPP_BEGIN_NAMESPACE_STD

template <class _Tp>
struct hash<_VSTD_CORO::coroutine_handle<_Tp> > {
    using __arg_type = _VSTD_CORO::coroutine_handle<_Tp>;
    _LIBCPP_INLINE_VISIBILITY
    size_t operator()(__arg_type const& __v) const _NOEXCEPT
    {return hash<void*>()(__v.address());}
};

_LIBCPP_END_NAMESPACE_STD

#endif // !defined(_LIBCPP_HAS_NO_COROUTINES)

#endif /* _LIBCPP_EXPERIMENTAL_COROUTINE */
